# 분할정복

주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산한다.

**일반 재귀 호출과 다른 점은 문제를 거의 같은 크기의 부분 문제로 나눈다는 점이다.**

</br>

### 1. 알고리즘 수행 과정

- 문제를 더 작은 문제로 분할하는 과정 (divide)

- 각 문제에 대한 답을 원래 문제에 대한 답으로 병합 (merge)

- 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 (base case)

  </br>

### 2. 분할 정복의 장점

1. 예제 : 수열의 빠른 합과 행렬의 빠른 제곱

- 1부터 n 까지의 합을 n 개의 조각으로 나눈 뒤, 이들을 반으로 잘라 $n/2$개의 조각들로 이만들어진 부분 문제 2개를 만든다.
  $$
  fastSum() = 1 + 2 + ... + n
            = (1 + 2 + ... + n/2)((n/2 + 1) + ... + n)
  $$
  </br>

  첫 번째 부분 문제는 fastSum(n/2)으로 나타낼 수 있지만, 두 번째 부분 문제는 그렇지 않다.

  → 문제를 재귀적으로 풀기 위해서는 각 부분 문제를 **'1부터 n까지의 합'** 꼴로 표현할 수 있어야  한다.

  </br>

  따라서, 두 번째 무문 문제를 fastSum(x)를 포함하는 형태
  $$
  (n/2 +1) + ... + n = (n/2 + 1) + (n/2 + 2) + ... + (n/2 + n/2)
  $$

  $$
   = n/2 * n/2 + (1 + 2 + ... + n/2)
  $$

  $$
  = fastSum(n/2) + n^2/4   
  $$

  </br>

  즉,  
  $$
  fastSum(n) = 2 * fastSum(n/2) + n^2/4
  $$
  이다.

  </br>

  ```kotlin
  fun fastSum(n: Int) {
  	if (n == 1) return 1
  	if (n % 2 == 1) return fastSum(n-1) + n
  	return 2 * fastSum(n/2) + (n/2) * (n/2)
  }
  ```

  </br>

  **호출될 때마다 최소한 두 번에 한 번 꼴로 n이 절반으로 줄어든다.**

  </br>

1. 행렬의 거듭제곱

- n * n 크기의 행렬 A가 주어질 때, A의 거듭제곱 A^m은 A를 연속해서 m번 곱한 것이다.

- 행렬의 곱셈에는 O(n^3)의 시간이 들기 때문에 A^m을 구하려면 모두 O(n^3 * m)번의 연산이 필요해 너무 느리다.

- A^m을 구하는데 필요한 m개의 조각을 절반으로 나눠보자.
  $$
  A^m = A^{m/2} * A^{m/2}
  $$
  

  m이 홀수일 때,
  $$
  A^m = A * A^{m-1}로 나누지 않고,   A^7 = A^3 * A^4
  $$
  나누는 것이 더 좋지 않을까라는 생각을 할 수 있다.

  </br>

  실제로 문제의 크기가 매번 절반에 가깝게 줄어들면 기저 사례에 도달하기까지 걸리는 분할의 횟수가 줄어들기 때문에 대두분의 `분할 정복 알고리즘`은 **가능한 한 절반에 가깝게 문제를 나누고자 한다.**

  → 그러나 이 문제에선, 그 방식의 분할은 알고리즘을 더 느리게 만든다.

  </br>

### 3. 병합 정렬과 퀵 정렬